#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <stdbool.h>
#include <float.h>

// ================== Layer: fc1 ================== //
// Transposed weights for layer: fc1 @5x10;
float fc1_weight_transposed[50] = {-0.16406250, -0.03053284, 0.43652344, -0.16003418, -0.16088867, 0.29516602, 0.22839355, -0.23376465, 0.30493164, -0.22094727, -0.28002930, -0.33081055, 0.42968750, -0.04772949, -0.12805176, 0.03472900, 0.09344482, 0.20727539, 0.21594238, -0.21484375, 0.13354492, 0.43676758, -0.41967773, 0.15197754, -0.33203125, -0.14294434, 0.19360352, 0.20629883, -0.43798828, -0.20922852, -0.17919922, -0.27246094, -0.07501221, 0.30053711, 0.41064453, 0.16235352, 0.10272217, -0.28344727, -0.23229980, 0.06567383, 0.23913574, -0.00428772, 0.13525391, 0.12170410, 0.08489990, 0.14843750, 0.31396484, -0.12939453, 0.22912598, -0.21130371};
// Biases for layer: fc1 @10;
float fc1_bias_transposed[10] = {0.19702148, 0.28100586, 0.30517578, 0.44116211, -0.28173828, 0.22448730, -0.01522827, 0.11877441, -0.41137695, 0.17773438};

// ================== Relu: relu1 ================== //
// Relu for layer: relu1;

// ================== Layer: fc2 ================== //
// Transposed weights for layer: fc2 @10x20;
float fc2_weight_transposed[200] = {-0.08892822, 0.21484375, 0.02734375, -0.24145508, 0.26611328, -0.24768066, 0.18103027, 0.15332031, 0.25927734, -0.23950195, -0.03970337, 0.08404541, 0.08325195, -0.07037354, 0.12133789, -0.01335144, -0.06683350, 0.14501953, 0.16198730, 0.22790527, 0.01956177, 0.14843750, 0.19616699, 0.16320801, -0.07904053, 0.00308228, -0.02777100, 0.24267578, -0.24157715, -0.28588867, 0.02313232, 0.15136719, 0.07489014, -0.05566406, 0.04705811, 0.31201172, 0.29223633, -0.30029297, -0.16284180, 0.02508545, 0.15161133, 0.18566895, 0.26855469, -0.20373535, 0.10552979, -0.24243164, 0.27514648, 0.30078125, -0.18994141, -0.11798096, -0.19055176, 0.02168274, 0.30566406, -0.15600586, -0.23400879, -0.08648682, -0.22363281, -0.19653320, 0.13110352, 0.01931763, -0.00700378, -0.29931641, -0.03005981, 0.20263672, 0.25073242, 0.06561279, -0.27416992, -0.29418945, 0.06872559, 0.18579102, -0.13513184, 0.11737061, -0.13342285, -0.30175781, -0.10876465, -0.07055664, -0.04843140, -0.18872070, 0.10406494, -0.15454102, 0.29028320, 0.02276611, 0.14074707, -0.03540039, 0.07849121, 0.20568848, -0.04214478, -0.27197266, 0.02456665, 0.07830811, -0.18139648, 0.22998047, -0.13952637, 0.28125000, 0.16394043, -0.18432617, -0.21691895, 0.09197998, 0.20104980, -0.26074219, -0.17541504, -0.28222656, 0.17907715, -0.23498535, -0.22021484, 0.00600815, -0.21606445, 0.24365234, -0.20812988, -0.24560547, -0.00489044, -0.16003418, 0.00031638, -0.11291504, -0.28808594, 0.27026367, 0.01243591, 0.22009277, 0.08312988, -0.02644348, 0.19812012, 0.00904083, -0.25122070, -0.23400879, 0.09759521, 0.19030762, -0.09887695, 0.25512695, -0.17541504, 0.21350098, 0.00346756, 0.05624390, 0.05862427, 0.27099609, -0.29003906, 0.25732422, -0.16418457, -0.07153320, 0.14025879, 0.06420898, -0.26196289, 0.03634644, -0.25878906, -0.03802490, -0.15893555, 0.08502197, 0.17163086, 0.08343506, -0.03302002, 0.28515625, 0.03280640, 0.21142578, -0.18847656, 0.02326965, 0.13671875, 0.28320312, -0.12963867, -0.16845703, 0.19543457, 0.01071167, 0.29003906, 0.29833984, 0.17346191, 0.02714539, -0.30957031, 0.08538818, -0.25708008, -0.09002686, -0.08282471, -0.19030762, -0.10882568, -0.15515137, 0.24841309, 0.31201172, 0.02958679, -0.01727295, 0.03399658, -0.15905762, 0.19995117, -0.26611328, 0.12371826, 0.21105957, 0.26660156, 0.05923462, -0.01162720, -0.07238770, -0.22851562, -0.22106934, -0.04058838, -0.20947266, -0.24902344, -0.19885254, -0.14709473, -0.12347412, -0.05203247, -0.00638962, 0.15283203, 0.12561035, 0.23437500, -0.02566528};
// Biases for layer: fc2 @20;
float fc2_bias_transposed[20] = {-0.24926758, 0.26562500, 0.06524658, 0.13989258, 0.30053711, 0.30908203, 0.12512207, -0.14794922, -0.13098145, -0.28320312, -0.19091797, -0.15161133, -0.05923462, -0.04330444, -0.20043945, 0.01568604, 0.20117188, 0.31274414, 0.02864075, -0.04101562};

// ================== LeakyRelu: tanh ================== //
// LeakyRelu for layer: tanh;

// ================== Layer: fc5 ================== //
// Transposed weights for layer: fc5 @20x3;
float fc5_weight_transposed[60] = {0.18688965, -0.17541504, -0.20996094, -0.17114258, 0.07708740, 0.12854004, -0.06774902, -0.01439667, -0.18896484, 0.00523758, 0.00152016, -0.06213379, -0.21960449, -0.00152302, -0.14941406, 0.15930176, 0.02465820, -0.01558685, 0.00112820, 0.10485840, 0.16406250, 0.04519653, -0.12927246, -0.15673828, 0.04052734, 0.04650879, -0.00675964, -0.11743164, 0.18029785, 0.13110352, 0.01710510, -0.03228760, 0.04177856, 0.10937500, -0.02336121, 0.09460449, -0.06027222, 0.17053223, 0.13378906, -0.14855957, 0.10894775, 0.08380127, 0.02148438, 0.14990234, -0.03652954, 0.03720093, 0.14685059, -0.20642090, -0.00077868, -0.15002441, 0.12347412, 0.01663208, -0.13464355, -0.04547119, -0.03921509, -0.09320068, -0.02249146, 0.06372070, 0.01114655, -0.17993164};
// Biases for layer: fc5 @3;
float fc5_bias_transposed[3] = {0.05508423, 0.20324707, -0.07836914};

// ================== SoftMax: softmax2 ================== //
// SoftMax for layer: softmax2;

float *Linear(int batch_size, int input_size, int output_size, float *input, float *weight_transposed, float *bias)
{
    int i, j, k;

    // 为结果矩阵分配内存
    float *result = (float *)malloc(batch_size * output_size * sizeof(float));
    if (result == NULL)
    {
        printf("Error: Memory allocation failed.\n");
        return NULL;
    }

    // 初始化并执行矩阵乘法
    for (i = 0; i < batch_size; i++)
    {
        for (j = 0; j < output_size; j++)
        {
            result[i * output_size + j] = 0; // 初始化元素为0
            for (k = 0; k < input_size; k++)
            {
                result[i * output_size + j] += input[i * input_size + k] * weight_transposed[k * output_size + j];
            }
            result[i * output_size + j] += bias[j]; // 将偏置项加到结果中
        }
    }

    // 返回结果矩阵
    return result;
}
void Relu(int batch_size, int elements_length, float *input)
{
    for (int i = 0; i < batch_size * elements_length; i++)
    {
        if (input[i] < 0)
        {
            input[i] = 0;
        }
    }
}
void LeakyReLU(int batch_size, int elements_length, float *input, float alpha)
{
    // 遍历输入数组的每个元素
    for (int i = 0; i < batch_size; i++)
    {
        for (int j = 0; j < elements_length; j++)
        {
            int index = i * elements_length + j;
            // 计算 LeakyReLU 值并更新输入数组
            if (input[index] < 0)
            {
                input[index] = alpha * input[index];
            }
            // 否则保持原值
        }
    }
}
void SoftMax(int batch_size, int elements_length, float *input)
{
    float max_value, sum_exp;

    // 逐行计算softmax
    for (int i = 0; i < batch_size; i++)
    {
        // 找到该行的最大值
        max_value = input[i * elements_length];
        for (int j = 1; j < elements_length; j++)
        {
            if (input[i * elements_length + j] > max_value)
            {
                max_value = input[i * elements_length + j];
            }
        }

        // 计算该行的指数和
        sum_exp = 0.0f;
        for (int j = 0; j < elements_length; j++)
        {
            input[i * elements_length + j] = exp(input[i * elements_length + j] - max_value);
            sum_exp += input[i * elements_length + j];
        }

        // 归一化得到softmax输出
        for (int j = 0; j < elements_length; j++)
        {
            input[i * elements_length + j] /= sum_exp;
        }
    }
}

void forward(float input[], float output[]){
	float* result_0=(float*)malloc(sizeof(float)*10);
for (int i = 0; i < 10; i++) { result_0[i] = input[i]; }
// fc1_layer
float* result_1 = Linear(2,5,10,result_0,fc1_weight_transposed,fc1_bias_transposed);
free(result_0);
// relu1_relu
Relu(2,10,result_1);
// fc2_layer
float* result_2 = Linear(2,10,20,result_1,fc2_weight_transposed,fc2_bias_transposed);
free(result_1);
// tanh_layer
LeakyReLU(2,20,result_2,0.5);
// fc5_layer
float* result_3 = Linear(2,20,3,result_2,fc5_weight_transposed,fc5_bias_transposed);
free(result_2);
// softmax2_layer
SoftMax(2,3,result_3);
for (int i = 0; i < 6; i++) { output[i] = result_3[i]; }
	free(result_3);
}
int main(){
float input[10] = { 1.001631259918213,-0.8055776953697205,1.4606553316116333,0.02235635370016098,2.3191421031951904,0.9080652594566345,-0.2772023677825928,1.1905566453933716,0.9003826379776001,-0.1986946165561676 };
float output[6];
forward(input, output);
for (int i = 0; i < 6; i++){ printf("%f  ", output[i]); 
 }
return 0;
}